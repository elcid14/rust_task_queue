use std::error::Error;
use std::time::Duration;

use futures_util::stream::StreamExt;
use lapin::{options::*, types::FieldTable, Connection, ConnectionProperties};
use serde_json::Value;
use tokio::task;
use tokio::time::timeout;

mod task_registry;
mod tasks;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    env_logger::init();

    let addr = std::env::var("AMQP_ADDR").unwrap_or("amqp://127.0.0.1:5672/%2f".into());
    let conn = Connection::connect(&addr, ConnectionProperties::default()).await?;
    let channel = conn.create_channel().await?;

    channel
        .queue_declare("task_queue", QueueDeclareOptions::default(), FieldTable::default())
        .await?;

    let mut consumer = channel
        .basic_consume(
            "task_queue",
            "task_worker",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await?;

    println!("üöÄ Listening for tasks...");

    while let Ok(Some(delivery)) = timeout(Duration::from_secs(10), consumer.next()).await {
        if let Ok((channel, delivery)) = delivery {
            task::spawn(async move {
                let parsed: Result<Value, _> = serde_json::from_slice(&delivery.data);
                match parsed {
                    Ok(msg) => {
                        let task_name = msg.get("task").and_then(|v| v.as_str()).unwrap_or("");
                        let payload = msg.get("payload").cloned().unwrap_or_default();

                        println!("üß† Received task: {}", task_name);

                        if task_registry::run_task(task_name, payload) {
                            let _ = channel
                                .basic_ack(delivery.delivery_tag, Default::default())
                                .await;
                        } else {
                            eprintln!("‚ùå Unknown task: {}", task_name);
                            let _ = channel
                                .basic_nack(delivery.delivery_tag, Default::default())
                                .await;
                        }
                    }
                    Err(e) => {
                        eprintln!("‚ùå Invalid JSON: {}", e);
                        let _ = channel
                            .basic_nack(delivery.delivery_tag, Default::default())
                            .await;
                    }
                }
            });
        }
    }

    println!("üõë No messages for 10 seconds. Shutting down.");
    Ok(())
}
